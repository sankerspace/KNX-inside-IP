package EIBConnection;
use Errno;
use Socket qw(IPPROTO_TCP TCP_NODELAY);
use Socket;
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use bytes;


 use constant IMG_UNKNOWN_ERROR => 0;
 use constant IMG_UNRECOG_FORMAT => 1;
 use constant IMG_INVALID_FORMAT => 2;
 use constant IMG_NO_BCUTYPE => 3;
 use constant IMG_UNKNOWN_BCUTYPE => 4;
 use constant IMG_NO_CODE => 5;
 use constant IMG_NO_SIZE => 6;
 use constant IMG_LODATA_OVERFLOW => 7;
 use constant IMG_HIDATA_OVERFLOW => 8;
 use constant IMG_TEXT_OVERFLOW => 9;
 use constant IMG_NO_ADDRESS => 10;
 use constant IMG_WRONG_SIZE => 11;
 use constant IMG_IMAGE_LOADABLE => 12;
 use constant IMG_NO_DEVICE_CONNECTION => 13;
 use constant IMG_MASK_READ_FAILED => 14;
 use constant IMG_WRONG_MASK_VERSION => 15;
 use constant IMG_CLEAR_ERROR => 16;
 use constant IMG_RESET_ADDR_TAB => 17;
 use constant IMG_LOAD_HEADER => 18;
 use constant IMG_LOAD_MAIN => 19;
 use constant IMG_ZERO_RAM => 20;
 use constant IMG_FINALIZE_ADDR_TAB => 21;
 use constant IMG_PREPARE_RUN => 22;
 use constant IMG_RESTART => 23;
 use constant IMG_LOADED => 24;
 use constant IMG_NO_START => 25;
 use constant IMG_WRONG_ADDRTAB => 26;
 use constant IMG_ADDRTAB_OVERFLOW => 27;
 use constant IMG_OVERLAP_ASSOCTAB => 28;
 use constant IMG_OVERLAP_TEXT => 29;
 use constant IMG_NEGATIV_TEXT_SIZE => 30;
 use constant IMG_OVERLAP_PARAM => 31;
 use constant IMG_OVERLAP_EEPROM => 32;
 use constant IMG_OBJTAB_OVERFLOW => 33;
 use constant IMG_WRONG_LOADCTL => 34;
 use constant IMG_UNLOAD_ADDR => 35;
 use constant IMG_UNLOAD_ASSOC => 36;
 use constant IMG_UNLOAD_PROG => 37;
 use constant IMG_LOAD_ADDR => 38;
 use constant IMG_WRITE_ADDR => 39;
 use constant IMG_SET_ADDR => 40;
 use constant IMG_FINISH_ADDR => 41;
 use constant IMG_LOAD_ASSOC => 42;
 use constant IMG_WRITE_ASSOC => 43;
 use constant IMG_SET_ASSOC => 44;
 use constant IMG_FINISH_ASSOC => 45;
 use constant IMG_LOAD_PROG => 46;
 use constant IMG_ALLOC_LORAM => 47;
 use constant IMG_ALLOC_HIRAM => 48;
 use constant IMG_ALLOC_INIT => 49;
 use constant IMG_ALLOC_RO => 50;
 use constant IMG_ALLOC_EEPROM => 51;
 use constant IMG_ALLOC_PARAM => 52;
 use constant IMG_SET_PROG => 53;
 use constant IMG_SET_TASK_PTR => 54;
 use constant IMG_SET_OBJ => 55;
 use constant IMG_SET_TASK2 => 56;
 use constant IMG_FINISH_PROC => 57;
 use constant IMG_WRONG_CHECKLIM => 58;
 use constant IMG_INVALID_KEY => 59;
 use constant IMG_AUTHORIZATION_FAILED => 60;
 use constant IMG_KEY_WRITE => 61;


sub EIBGetAPDU_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0025 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIBGetAPDU_async { my ($self , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $self->{complete} = "EIBGetAPDU" . "_complete"; return 0; } sub EIBGetAPDU { my ($self , $buf ) = @_; $self -> EIBGetAPDU_async ( $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIBGetAPDU_Src_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0025 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr5}) { ${$self->{ptr5}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } ${$self->{buf}} = substr($self->{data}, 4); return bytes::length(${$self->{buf}}); }
sub EIBGetAPDU_Src_async { my ($self , $buf , $src ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $self->{ptr5} = $src; $self->{complete} = "EIBGetAPDU_Src" . "_complete"; return 0; } sub EIBGetAPDU_Src { my ($self , $buf , $src ) = @_; $self -> EIBGetAPDU_Src_async ( $buf , $src )==0 or return undef; return $self -> EIBComplete(); }

sub EIBGetBusmonitorPacket_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0014 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIBGetBusmonitorPacket_async { my ($self , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $self->{complete} = "EIBGetBusmonitorPacket" . "_complete"; return 0; } sub EIBGetBusmonitorPacket { my ($self , $buf ) = @_; $self -> EIBGetBusmonitorPacket_async ( $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIBGetBusmonitorPacketTS_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0015 || bytes::length($self->{data}) < 7) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr2}) { ${$self->{ptr2}} = ($self->{data}[2]); } if (defined $self->{ptr7}) { ${$self->{ptr7}} = ((vec($self->{data},3,8) << 24) | (vec($self->{data},3 +1,8) << 16)| (vec($self->{data},3 +2,8) << 8)| (vec($self->{data},3 +3,8))); } ${$self->{buf}} = substr($self->{data}, 7); return bytes::length(${$self->{buf}}); }
sub EIBGetBusmonitorPacketTS_async { my ($self , $status , $timestamp , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{ptr2} = $status; $self->{ptr7} = $timestamp; $self->{buf} = $buf; $self->{complete} = "EIBGetBusmonitorPacketTS" . "_complete"; return 0; } sub EIBGetBusmonitorPacketTS { my ($self , $status , $timestamp , $buf ) = @_; $self -> EIBGetBusmonitorPacketTS_async ( $status , $timestamp , $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIBGetGroup_Src_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0027 || bytes::length($self->{data}) < 6) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr5}) { ${$self->{ptr5}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } if (defined $self->{ptr6}) { ${$self->{ptr6}} = ((vec($self->{data},4,8) << 8) | (vec($self->{data},4 +1,8))); } ${$self->{buf}} = substr($self->{data}, 6); return bytes::length(${$self->{buf}}); }
sub EIBGetGroup_Src_async { my ($self , $buf , $src , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $self->{ptr5} = $src; $self->{ptr6} = $dest; $self->{complete} = "EIBGetGroup_Src" . "_complete"; return 0; } sub EIBGetGroup_Src { my ($self , $buf , $src , $dest ) = @_; $self -> EIBGetGroup_Src_async ( $buf , $src , $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIBGetTPDU_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0025 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr5}) { ${$self->{ptr5}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } ${$self->{buf}} = substr($self->{data}, 4); return bytes::length(${$self->{buf}}); }
sub EIBGetTPDU_async { my ($self , $buf , $src ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $self->{ptr5} = $src; $self->{complete} = "EIBGetTPDU" . "_complete"; return 0; } sub EIBGetTPDU { my ($self , $buf , $src ) = @_; $self -> EIBGetTPDU_async ( $buf , $src )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Clear_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0072 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_Cache_Clear_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0072>>8)&0xff; $ibuf[1] = (0x0072)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Clear" . "_complete"; return 0; } sub EIB_Cache_Clear { my ($self ) = @_; $self -> EIB_Cache_Clear_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Disable_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0071 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_Cache_Disable_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0071>>8)&0xff; $ibuf[1] = (0x0071)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Disable" . "_complete"; return 0; } sub EIB_Cache_Disable { my ($self ) = @_; $self -> EIB_Cache_Disable_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Enable_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0070 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_Cache_Enable_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0070>>8)&0xff; $ibuf[1] = (0x0070)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Enable" . "_complete"; return 0; } sub EIB_Cache_Enable { my ($self ) = @_; $self -> EIB_Cache_Enable_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Read_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0075 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } if (((vec($self->{data},4,8) << 8) | (vec($self->{data},4 +1,8))) == 0) { $! = &Errno::ENODEV; return undef; } if (bytes::length($self->{data}) <= 6) { $! = &Errno::ENOENT; return undef; } if (defined $self->{ptr5}) { ${$self->{ptr5}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } ${$self->{buf}} = substr($self->{data}, 6); return bytes::length(${$self->{buf}}); }
sub EIB_Cache_Read_async { my ($self , $dst , $src , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $self->{buf} = $buf; $self->{ptr5} = $src; $ibuf[2] = ($dst>>8)&0xff; $ibuf[2 +1] = ($dst)&0xff; $ibuf[0] = (0x0075>>8)&0xff; $ibuf[1] = (0x0075)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Read" . "_complete"; return 0; } sub EIB_Cache_Read { my ($self , $dst , $src , $buf ) = @_; $self -> EIB_Cache_Read_async ( $dst , $src , $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Read_Sync_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0074 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } if (((vec($self->{data},4,8) << 8) | (vec($self->{data},4 +1,8))) == 0) { $! = &Errno::ENODEV; return undef; } if (bytes::length($self->{data}) <= 6) { $! = &Errno::ENOENT; return undef; } if (defined $self->{ptr5}) { ${$self->{ptr5}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } ${$self->{buf}} = substr($self->{data}, 6); return bytes::length(${$self->{buf}}); }
sub EIB_Cache_Read_Sync_async { my ($self , $dst , $src , $buf , $age ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<6; $i++) { $ibuf[$i]=0x00; } my $headlen = 6; $self->{buf} = $buf; $self->{ptr5} = $src; $ibuf[2] = ($dst>>8)&0xff; $ibuf[2 +1] = ($dst)&0xff; $ibuf[4] = ($age>>8)&0xff; $ibuf[4 +1] = ($age)&0xff; $ibuf[0] = (0x0074>>8)&0xff; $ibuf[1] = (0x0074)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Read_Sync" . "_complete"; return 0; } sub EIB_Cache_Read_Sync { my ($self , $dst , $src , $buf , $age ) = @_; $self -> EIB_Cache_Read_Sync_async ( $dst , $src , $buf , $age )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_Remove_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0073 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_Cache_Remove_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0073>>8)&0xff; $ibuf[1] = (0x0073)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_Remove" . "_complete"; return 0; } sub EIB_Cache_Remove { my ($self , $dest ) = @_; $self -> EIB_Cache_Remove_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_Cache_LastUpdates_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0076 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr4}) { ${$self->{ptr4}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } ${$self->{buf}} = substr($self->{data}, 4); return bytes::length(${$self->{buf}}); }
sub EIB_Cache_LastUpdates_async { my ($self , $start , $timeout , $buf , $ende ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $self->{buf} = $buf; $self->{ptr4} = $ende; $ibuf[2] = ($start>>8)&0xff; $ibuf[2 +1] = ($start)&0xff; $ibuf[4] = ($timeout)&0xff; $ibuf[0] = (0x0076>>8)&0xff; $ibuf[1] = (0x0076)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_Cache_LastUpdates" . "_complete"; return 0; } sub EIB_Cache_LastUpdates { my ($self , $start , $timeout , $buf , $ende ) = @_; $self -> EIB_Cache_LastUpdates_async ( $start , $timeout , $buf , $ende )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_LoadImage_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0063 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } return ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); }
sub EIB_LoadImage_async { my ($self , $image ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; if (bytes::length($image) < 0) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($image); for ($i = 0; $i < bytes::length($image); $i++) { $ibuf[$headlen + $i] = vec($image,$i,8); } $ibuf[0] = (0x0063>>8)&0xff; $ibuf[1] = (0x0063)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_LoadImage" . "_complete"; return 0; } sub EIB_LoadImage { my ($self , $image ) = @_; $self -> EIB_LoadImage_async ( $image )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Authorize_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0057 || bytes::length($self->{data}) < 3) { $! = &Errno::ECONNRESET; return undef; } return ($self->{data}[2]); }
sub EIB_MC_Authorize_async { my ($self , $key ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<6; $i++) { $ibuf[$i]=0x00; } my $headlen = 6; if (@key != 4) { $! = &Errno::EINVAL; return undef; } for ($i = 0; $i < 4; $i++) { $ibuf [2 + $i] = vec($key,$i,8); } $ibuf[0] = (0x0057>>8)&0xff; $ibuf[1] = (0x0057)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Authorize" . "_complete"; return 0; } sub EIB_MC_Authorize { my ($self , $key ) = @_; $self -> EIB_MC_Authorize_async ( $key )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Connect_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0050 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Connect_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0050>>8)&0xff; $ibuf[1] = (0x0050)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Connect" . "_complete"; return 0; } sub EIB_MC_Connect { my ($self , $dest ) = @_; $self -> EIB_MC_Connect_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Individual_Open_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0049 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Individual_Open_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0049>>8)&0xff; $ibuf[1] = (0x0049)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Individual_Open" . "_complete"; return 0; } sub EIB_MC_Individual_Open { my ($self , $dest ) = @_; $self -> EIB_MC_Individual_Open_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_GetMaskVersion_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0059 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } return ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); }
sub EIB_MC_GetMaskVersion_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0059>>8)&0xff; $ibuf[1] = (0x0059)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_GetMaskVersion" . "_complete"; return 0; } sub EIB_MC_GetMaskVersion { my ($self ) = @_; $self -> EIB_MC_GetMaskVersion_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_GetPEIType_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0055 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } return ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); }
sub EIB_MC_GetPEIType_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0055>>8)&0xff; $ibuf[1] = (0x0055)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_GetPEIType" . "_complete"; return 0; } sub EIB_MC_GetPEIType { my ($self ) = @_; $self -> EIB_MC_GetPEIType_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Progmode_Off_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0060 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Progmode_Off_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<3; $i++) { $ibuf[$i]=0x00; } my $headlen = 3; $ibuf[2] = ((0))&0xff; $ibuf[0] = (0x0060>>8)&0xff; $ibuf[1] = (0x0060)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Progmode_Off" . "_complete"; return 0; } sub EIB_MC_Progmode_Off { my ($self ) = @_; $self -> EIB_MC_Progmode_Off_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Progmode_On_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0060 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Progmode_On_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<3; $i++) { $ibuf[$i]=0x00; } my $headlen = 3; $ibuf[2] = ((1))&0xff; $ibuf[0] = (0x0060>>8)&0xff; $ibuf[1] = (0x0060)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Progmode_On" . "_complete"; return 0; } sub EIB_MC_Progmode_On { my ($self ) = @_; $self -> EIB_MC_Progmode_On_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Progmode_Status_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0060 || bytes::length($self->{data}) < 3) { $! = &Errno::ECONNRESET; return undef; } return ($self->{data}[2]); }
sub EIB_MC_Progmode_Status_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<3; $i++) { $ibuf[$i]=0x00; } my $headlen = 3; $ibuf[2] = ((3))&0xff; $ibuf[0] = (0x0060>>8)&0xff; $ibuf[1] = (0x0060)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Progmode_Status" . "_complete"; return 0; } sub EIB_MC_Progmode_Status { my ($self ) = @_; $self -> EIB_MC_Progmode_Status_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Progmode_Toggle_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0060 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Progmode_Toggle_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<3; $i++) { $ibuf[$i]=0x00; } my $headlen = 3; $ibuf[2] = ((2))&0xff; $ibuf[0] = (0x0060>>8)&0xff; $ibuf[1] = (0x0060)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Progmode_Toggle" . "_complete"; return 0; } sub EIB_MC_Progmode_Toggle { my ($self ) = @_; $self -> EIB_MC_Progmode_Toggle_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_PropertyDesc_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0061 || bytes::length($self->{data}) < 6) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr2}) { ${$self->{ptr2}} = ($self->{data}[2]); } if (defined $self->{ptr4}) { ${$self->{ptr4}} = ((vec($self->{data},3,8) << 8) | (vec($self->{data},3 +1,8))); } if (defined $self->{ptr3}) { ${$self->{ptr3}} = ($self->{data}[5]); } return 0; }
sub EIB_MC_PropertyDesc_async { my ($self , $obj , $propertyno , $proptype , $max_nr_of_elem , $access ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $self->{ptr2} = $proptype; $self->{ptr4} = $max_nr_of_elem; $self->{ptr3} = $access; $ibuf[2] = ($obj)&0xff; $ibuf[3] = ($propertyno)&0xff; $ibuf[0] = (0x0061>>8)&0xff; $ibuf[1] = (0x0061)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_PropertyDesc" . "_complete"; return 0; } sub EIB_MC_PropertyDesc { my ($self , $obj , $propertyno , $proptype , $max_nr_of_elem , $access ) = @_; $self -> EIB_MC_PropertyDesc_async ( $obj , $propertyno , $proptype , $max_nr_of_elem , $access )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_PropertyRead_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0053 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIB_MC_PropertyRead_async { my ($self , $obj , $propertyno , $start , $nr_of_elem , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<7; $i++) { $ibuf[$i]=0x00; } my $headlen = 7; $self->{buf} = $buf; $ibuf[2] = ($obj)&0xff; $ibuf[3] = ($propertyno)&0xff; $ibuf[4] = ($start>>8)&0xff; $ibuf[4 +1] = ($start)&0xff; $ibuf[6] = ($nr_of_elem)&0xff; $ibuf[0] = (0x0053>>8)&0xff; $ibuf[1] = (0x0053)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_PropertyRead" . "_complete"; return 0; } sub EIB_MC_PropertyRead { my ($self , $obj , $propertyno , $start , $nr_of_elem , $buf ) = @_; $self -> EIB_MC_PropertyRead_async ( $obj , $propertyno , $start , $nr_of_elem , $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_PropertyScan_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0062 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIB_MC_PropertyScan_async { my ($self , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $ibuf[0] = (0x0062>>8)&0xff; $ibuf[1] = (0x0062)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_PropertyScan" . "_complete"; return 0; } sub EIB_MC_PropertyScan { my ($self , $buf ) = @_; $self -> EIB_MC_PropertyScan_async ( $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_PropertyWrite_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0054 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIB_MC_PropertyWrite_async { my ($self , $obj , $propertyno , $start , $nr_of_elem , $buf , $res ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<7; $i++) { $ibuf[$i]=0x00; } my $headlen = 7; $ibuf[2] = ($obj)&0xff; $ibuf[3] = ($propertyno)&0xff; $ibuf[4] = ($start>>8)&0xff; $ibuf[4 +1] = ($start)&0xff; $ibuf[6] = ($nr_of_elem)&0xff; if (bytes::length($buf) < 0) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($buf); for ($i = 0; $i < bytes::length($buf); $i++) { $ibuf[$headlen + $i] = vec($buf,$i,8); } $self->{buf} = $res; $ibuf[0] = (0x0054>>8)&0xff; $ibuf[1] = (0x0054)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_PropertyWrite" . "_complete"; return 0; } sub EIB_MC_PropertyWrite { my ($self , $obj , $propertyno , $start , $nr_of_elem , $buf , $res ) = @_; $self -> EIB_MC_PropertyWrite_async ( $obj , $propertyno , $start , $nr_of_elem , $buf , $res )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_ReadADC_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0056 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr1}) { ${$self->{ptr1}} = ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); } return 0; }
sub EIB_MC_ReadADC_async { my ($self , $channel , $count , $val ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $self->{ptr1} = $val; $ibuf[2] = ($channel)&0xff; $ibuf[3] = ($count)&0xff; $ibuf[0] = (0x0056>>8)&0xff; $ibuf[1] = (0x0056)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_ReadADC" . "_complete"; return 0; } sub EIB_MC_ReadADC { my ($self , $channel , $count , $val ) = @_; $self -> EIB_MC_ReadADC_async ( $channel , $count , $val )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Read_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0051 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIB_MC_Read_async { my ($self , $addr , $buf_len, $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<6; $i++) { $ibuf[$i]=0x00; } my $headlen = 6; $self->{buf} = $buf; $ibuf[2] = ($addr>>8)&0xff; $ibuf[2 +1] = ($addr)&0xff; $ibuf[4] = ((($buf_len))>>8)&0xff; $ibuf[4 +1] = ((($buf_len)))&0xff; $ibuf[0] = (0x0051>>8)&0xff; $ibuf[1] = (0x0051)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Read" . "_complete"; return 0; } sub EIB_MC_Read { my ($self , $addr , $buf_len, $buf ) = @_; $self -> EIB_MC_Read_async ( $addr , $buf_len, $name )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Restart_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x005a || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_Restart_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x005a>>8)&0xff; $ibuf[1] = (0x005a)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Restart" . "_complete"; return 0; } sub EIB_MC_Restart { my ($self ) = @_; $self -> EIB_MC_Restart_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_SetKey_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0002) { $! = &Errno::EPERM; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0058 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_MC_SetKey_async { my ($self , $key , $level ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<7; $i++) { $ibuf[$i]=0x00; } my $headlen = 7; if (@key != 4) { $! = &Errno::EINVAL; return undef; } for ($i = 0; $i < 4; $i++) { $ibuf [2 + $i] = vec($key,$i,8); } $ibuf[6] = ($level)&0xff; $ibuf[0] = (0x0058>>8)&0xff; $ibuf[1] = (0x0058)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_SetKey" . "_complete"; return 0; } sub EIB_MC_SetKey { my ($self , $key , $level ) = @_; $self -> EIB_MC_SetKey_async ( $key , $level )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Write_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0044) { $! = &Errno::EIO; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0052 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return $self->{sendlen}; }
sub EIB_MC_Write_async { my ($self , $addr , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<6; $i++) { $ibuf[$i]=0x00; } my $headlen = 6; $ibuf[2] = ($addr>>8)&0xff; $ibuf[2 +1] = ($addr)&0xff; $ibuf[4] = ((($buf))>>8)&0xff; $ibuf[4 +1] = ((($buf)))&0xff; if (bytes::length($buf) < 0) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($buf); for ($i = 0; $i < bytes::length($buf); $i++) { $ibuf[$headlen + $i] = vec($buf,$i,8); } $ibuf[0] = (0x0052>>8)&0xff; $ibuf[1] = (0x0052)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Write" . "_complete"; return 0; } sub EIB_MC_Write { my ($self , $addr , $buf ) = @_; $self -> EIB_MC_Write_async ( $addr , $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_MC_Write_Plain_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x005b || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return $self->{sendlen}; }
sub EIB_MC_Write_Plain_async { my ($self , $addr , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<6; $i++) { $ibuf[$i]=0x00; } my $headlen = 6; $ibuf[2] = ($addr>>8)&0xff; $ibuf[2 +1] = ($addr)&0xff; $ibuf[4] = ((($buf))>>8)&0xff; $ibuf[4 +1] = ((($buf)))&0xff; if (bytes::length($buf) < 0) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($buf); for ($i = 0; $i < bytes::length($buf); $i++) { $ibuf[$headlen + $i] = vec($buf,$i,8); } $ibuf[0] = (0x005b>>8)&0xff; $ibuf[1] = (0x005b)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_MC_Write_Plain" . "_complete"; return 0; } sub EIB_MC_Write_Plain { my ($self , $addr , $buf ) = @_; $self -> EIB_MC_Write_Plain_async ( $addr , $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_GetMaskVersion_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0031 || bytes::length($self->{data}) < 4) { $! = &Errno::ECONNRESET; return undef; } return ((vec($self->{data},2,8) << 8) | (vec($self->{data},2 +1,8))); }
sub EIB_M_GetMaskVersion_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0031>>8)&0xff; $ibuf[1] = (0x0031)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_GetMaskVersion" . "_complete"; return 0; } sub EIB_M_GetMaskVersion { my ($self , $dest ) = @_; $self -> EIB_M_GetMaskVersion_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_Progmode_Off_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0030 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_M_Progmode_Off_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ((0))&0xff; $ibuf[0] = (0x0030>>8)&0xff; $ibuf[1] = (0x0030)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_Progmode_Off" . "_complete"; return 0; } sub EIB_M_Progmode_Off { my ($self , $dest ) = @_; $self -> EIB_M_Progmode_Off_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_Progmode_On_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0030 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_M_Progmode_On_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ((1))&0xff; $ibuf[0] = (0x0030>>8)&0xff; $ibuf[1] = (0x0030)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_Progmode_On" . "_complete"; return 0; } sub EIB_M_Progmode_On { my ($self , $dest ) = @_; $self -> EIB_M_Progmode_On_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_Progmode_Status_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0030 || bytes::length($self->{data}) < 3) { $! = &Errno::ECONNRESET; return undef; } return ($self->{data}[2]); }
sub EIB_M_Progmode_Status_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ((3))&0xff; $ibuf[0] = (0x0030>>8)&0xff; $ibuf[1] = (0x0030)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_Progmode_Status" . "_complete"; return 0; } sub EIB_M_Progmode_Status { my ($self , $dest ) = @_; $self -> EIB_M_Progmode_Status_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_Progmode_Toggle_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0030 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_M_Progmode_Toggle_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ((2))&0xff; $ibuf[0] = (0x0030>>8)&0xff; $ibuf[1] = (0x0030)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_Progmode_Toggle" . "_complete"; return 0; } sub EIB_M_Progmode_Toggle { my ($self , $dest ) = @_; $self -> EIB_M_Progmode_Toggle_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_ReadIndividualAddresses_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0032 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } ${$self->{buf}} = substr($self->{data}, 2); return bytes::length(${$self->{buf}}); }
sub EIB_M_ReadIndividualAddresses_async { my ($self , $buf ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{buf} = $buf; $ibuf[0] = (0x0032>>8)&0xff; $ibuf[1] = (0x0032)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_ReadIndividualAddresses" . "_complete"; return 0; } sub EIB_M_ReadIndividualAddresses { my ($self , $buf ) = @_; $self -> EIB_M_ReadIndividualAddresses_async ( $buf )==0 or return undef; return $self -> EIBComplete(); }

sub EIB_M_WriteIndividualAddress_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0041) { $! = &Errno::EADDRINUSE; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0043) { $! = &Errno::ETIMEDOUT; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0042) { $! = &Errno::EADDRNOTAVAIL; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0040 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIB_M_WriteIndividualAddress_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0040>>8)&0xff; $ibuf[1] = (0x0040)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIB_M_WriteIndividualAddress" . "_complete"; return 0; } sub EIB_M_WriteIndividualAddress { my ($self , $dest ) = @_; $self -> EIB_M_WriteIndividualAddress_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenBusmonitor_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0010 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenBusmonitor_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0010>>8)&0xff; $ibuf[1] = (0x0010)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenBusmonitor" . "_complete"; return 0; } sub EIBOpenBusmonitor { my ($self ) = @_; $self -> EIBOpenBusmonitor_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenBusmonitorText_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0011 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenBusmonitorText_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0011>>8)&0xff; $ibuf[1] = (0x0011)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenBusmonitorText" . "_complete"; return 0; } sub EIBOpenBusmonitorText { my ($self ) = @_; $self -> EIBOpenBusmonitorText_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenBusmonitorTS_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0016 || bytes::length($self->{data}) < 6) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr7}) { ${$self->{ptr7}} = ((vec($self->{data},2,8) << 24) | (vec($self->{data},2 +1,8) << 16)| (vec($self->{data},2 +2,8) << 8)| (vec($self->{data},2 +3,8))); } return 0; }
sub EIBOpenBusmonitorTS_async { my ($self , $timebase ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{ptr7} = $timebase; $ibuf[0] = (0x0016>>8)&0xff; $ibuf[1] = (0x0016)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenBusmonitorTS" . "_complete"; return 0; } sub EIBOpenBusmonitorTS { my ($self , $timebase ) = @_; $self -> EIBOpenBusmonitorTS_async ( $timebase )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpen_GroupSocket_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0026 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpen_GroupSocket_async { my ($self , $write_only ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[4] = ($write_only) ? 0xff : 0; $ibuf[0] = (0x0026>>8)&0xff; $ibuf[1] = (0x0026)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpen_GroupSocket" . "_complete"; return 0; } sub EIBOpen_GroupSocket { my ($self , $write_only ) = @_; $self -> EIBOpen_GroupSocket_async ( $write_only )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenT_Broadcast_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0023 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenT_Broadcast_async { my ($self , $write_only ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[4] = ($write_only) ? 0xff : 0; $ibuf[0] = (0x0023>>8)&0xff; $ibuf[1] = (0x0023)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenT_Broadcast" . "_complete"; return 0; } sub EIBOpenT_Broadcast { my ($self , $write_only ) = @_; $self -> EIBOpenT_Broadcast_async ( $write_only )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenT_Connection_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0020 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenT_Connection_async { my ($self , $dest ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[0] = (0x0020>>8)&0xff; $ibuf[1] = (0x0020)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenT_Connection" . "_complete"; return 0; } sub EIBOpenT_Connection { my ($self , $dest ) = @_; $self -> EIBOpenT_Connection_async ( $dest )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenT_Group_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0022 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenT_Group_async { my ($self , $dest , $write_only ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ($write_only) ? 0xff : 0; $ibuf[0] = (0x0022>>8)&0xff; $ibuf[1] = (0x0022)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenT_Group" . "_complete"; return 0; } sub EIBOpenT_Group { my ($self , $dest , $write_only ) = @_; $self -> EIBOpenT_Group_async ( $dest , $write_only )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenT_Individual_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0021 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenT_Individual_async { my ($self , $dest , $write_only ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; $ibuf[4] = ($write_only) ? 0xff : 0; $ibuf[0] = (0x0021>>8)&0xff; $ibuf[1] = (0x0021)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenT_Individual" . "_complete"; return 0; } sub EIBOpenT_Individual { my ($self , $dest , $write_only ) = @_; $self -> EIBOpenT_Individual_async ( $dest , $write_only )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenT_TPDU_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0024 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenT_TPDU_async { my ($self , $src ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<5; $i++) { $ibuf[$i]=0x00; } my $headlen = 5; $ibuf[2] = ($src>>8)&0xff; $ibuf[2 +1] = ($src)&0xff; $ibuf[0] = (0x0024>>8)&0xff; $ibuf[1] = (0x0024)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenT_TPDU" . "_complete"; return 0; } sub EIBOpenT_TPDU { my ($self , $src ) = @_; $self -> EIBOpenT_TPDU_async ( $src )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenVBusmonitor_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0012 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenVBusmonitor_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0012>>8)&0xff; $ibuf[1] = (0x0012)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenVBusmonitor" . "_complete"; return 0; } sub EIBOpenVBusmonitor { my ($self ) = @_; $self -> EIBOpenVBusmonitor_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenVBusmonitorText_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0013 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBOpenVBusmonitorText_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0013>>8)&0xff; $ibuf[1] = (0x0013)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenVBusmonitorText" . "_complete"; return 0; } sub EIBOpenVBusmonitorText { my ($self ) = @_; $self -> EIBOpenVBusmonitorText_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIBOpenVBusmonitorTS_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) == 0x0001) { $! = &Errno::EBUSY; return undef; } if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0017 || bytes::length($self->{data}) < 6) { $! = &Errno::ECONNRESET; return undef; } if (defined $self->{ptr7}) { ${$self->{ptr7}} = ((vec($self->{data},2,8) << 24) | (vec($self->{data},2 +1,8) << 16)| (vec($self->{data},2 +2,8) << 8)| (vec($self->{data},2 +3,8))); } return 0; }
sub EIBOpenVBusmonitorTS_async { my ($self , $timebase ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $self->{ptr7} = $timebase; $ibuf[0] = (0x0017>>8)&0xff; $ibuf[1] = (0x0017)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBOpenVBusmonitorTS" . "_complete"; return 0; } sub EIBOpenVBusmonitorTS { my ($self , $timebase ) = @_; $self -> EIBOpenVBusmonitorTS_async ( $timebase )==0 or return undef; return $self -> EIBComplete(); }

sub EIBReset_complete { my $self = shift; $self->{complete} = undef; my $i; $self->_EIB_Get_Request()==0 or return undef; if ((((vec($self->{data},0,8) << 8) | (vec($self->{data},0 +1,8)))) != 0x0004 || bytes::length($self->{data}) < 2) { $! = &Errno::ECONNRESET; return undef; } return 0; }
sub EIBReset_async { my ($self ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; $ibuf[0] = (0x0004>>8)&0xff; $ibuf[1] = (0x0004)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; $self->{complete} = "EIBReset" . "_complete"; return 0; } sub EIBReset { my ($self ) = @_; $self -> EIBReset_async ( )==0 or return undef; return $self -> EIBComplete(); }

sub EIBSendAPDU { my ($self , $data ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<2; $i++) { $ibuf[$i]=0x00; } my $headlen = 2; if (bytes::length($data) < 2) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($data); for ($i = 0; $i < bytes::length($data); $i++) { $ibuf[$headlen + $i] = vec($data,$i,8); } $ibuf[0] = (0x0025>>8)&0xff; $ibuf[1] = (0x0025)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; return $self->{sendlen}; }

sub EIBSendGroup { my ($self , $dest , $data ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; if (bytes::length($data) < 2) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($data); for ($i = 0; $i < bytes::length($data); $i++) { $ibuf[$headlen + $i] = vec($data,$i,8); } $ibuf[0] = (0x0027>>8)&0xff; $ibuf[1] = (0x0027)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; return $self->{sendlen}; }

sub EIBSendTPDU { my ($self , $dest , $data ) = @_; my $i; my @ibuf = {}; for ($i = 0; $i<4; $i++) { $ibuf[$i]=0x00; } my $headlen = 4; $ibuf[2] = ($dest>>8)&0xff; $ibuf[2 +1] = ($dest)&0xff; if (bytes::length($data) < 2) { $! = &Errno::EINVAL; return undef; } $self->{sendlen} = bytes::length($data); for ($i = 0; $i < bytes::length($data); $i++) { $ibuf[$headlen + $i] = vec($data,$i,8); } $ibuf[0] = (0x0025>>8)&0xff; $ibuf[1] = (0x0025)&0xff; $self->_EIB_SendRequest (pack("C".@ibuf, @ibuf))==0 or return undef; return $self->{sendlen}; }
sub EIBSocketLocal {
    my $class = shift;
    my $self = {};
    bless ($self, $class);
    my ($path) = @_;
    socket($self->{fd}, PF_UNIX, SOCK_STREAM, 0);
    connect($self->{fd}, sockaddr_un($path)) or return undef;
    $self->{data} = {};
    $self->{readlen} = 0;
    return $self;
}
sub EIBSocketRemote {
    my $class = shift;
    my $self = {};
    bless ($self, $class);
    my ($ip, $port) = @_;
    my $host = gethostbyname($ip) or return undef;
    $port = $port || 6720;
    socket($self->{fd}, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
    connect($self->{fd}, sockaddr_in($port, $host)) or return undef;
    setsockopt($self->{fd}, IPPROTO_TCP, &TCP_NODELAY, 1);
    $self->{data} = {};
    $self->{readlen} = 0;
    return $self;
}
sub EIBSocketURL {
    my $class = shift;
    my ($url) = @_;
    if ($url =~ /^local:(.*)$/ )
    {
 return $class->EIBSocketLocal($1);
    }
    if ($url =~ /^ip:([^:]+)(:[0-9]+)?$/ )
    {
 my $port = (defined $2 ? substr($2, 1) : undef);
 return $class->EIBSocketRemote($1, $port);
    }
    $! = &Errno::EINVAL;
    return undef;
}
sub EIBSocketClose_sync {
    my $self = shift;
    $self->EIBReset();
    return $self->EIBClose();
}
sub EIBClose {
    my $self = shift;
    close($self->{fd}) or return undef;
    $self->{fd} = undef;
    return 0;
}
sub _EIB_SendRequest {
    my $self = shift;
    my ($data) = @_;
    my $result;
    if (!defined $self->{fd})
    {
 $! = &Errno::ECONNRESET;
 return undef;
    }
    if (bytes::length($data) >= 0xffff || bytes::length($data) < 2)
    {
 $! = &Errno::EINVAL;
 return undef;
    }
    $result = pack ("n", bytes::length($data)). $data;
    defined(send($self->{fd}, $result, 0)) or return undef;
    return 0;
}
sub _EIB_CheckRequest {
    my $self = shift;
    my $buffer;
    my $i;
    my ($block) = @_;
    if (!defined $self->{fd})
    {
 $! = &Errno::ECONNRESET;
 return undef;
    }
    if ($self->{readlen} == 0)
    {
 $self->{data} = "";
 $self->{head} = "";
    }
    if ($self->{readlen} < 2)
    {
 fcntl($self->{fd}, F_SETFL, (fcntl($self->{fd}, F_GETFL, 0) & ~O_NONBLOCK) | ($block ? 0 : O_NONBLOCK ));
 if (!defined(recv($self->{fd}, $buffer, 2 - $self->{readlen}, 0)))
 {
     $! = &Errno::ECONNRESET;
     return -1;
 }
 $self->{head}.=$buffer;
 $self->{readlen}+=bytes::length($buffer);
    }
    if ($self->{readlen} < 2)
    {
 return 0;
    }
    $self->{datalen} = unpack("n", $self->{head});
    if ($self->{readlen} < $self->{datalen} + 2)
    {
 fcntl($self->{fd}, F_SETFL, (fcntl($self->{fd}, F_GETFL, 0) & ~O_NONBLOCK) | ($block ? 0 : O_NONBLOCK ));
 if (!defined(recv($self->{fd}, $buffer, $self->{datalen} + 2 - $self->{readlen}, 0)))
 {
     $! = &Errno::ECONNRESET;
     return undef;
 }
 $self->{data}.=$buffer;
 $self->{readlen}+=bytes::length($buffer);
    }
    return 0;
}
sub _EIB_Get_Request {
    my $self = shift;
    do {
 defined($self->_EIB_CheckRequest(true)) or return undef;
    } while ($self->{readlen} < 2 || ($self->{readlen} >= 2 && $self->{readlen} < $self->{datalen} + 2));
    $self->{readlen} = 0;
    return 0;
}
sub EIB_Poll_Complete {
    my $self = shift;
    defined($self->_EIB_CheckRequest(false)) or return undef;
    if ($self->{readlen} < 2 || ($self->{readlen} >= 2 && $self->{readlen} < $self->{datalen} + 2))
    {
 return 0;
    }
    return 1;
}
sub EIB_Poll_FD {
    my $self = shift;
    if (!defined $self->{fd})
    {
 $! = &Errno::EINVAL;
 return undef;
    }
    return $self->{fd};
}
sub EIBComplete {
    my $self = shift;
    my $func = $self->{complete};
    if (!defined $self->{fd} || !defined $func)
    {
 $! = &Errno::EINVAL;
 return undef;
    }
    $self->$func()
}
sub EIBBuffer {
 my $buffer = "";
 return \$buffer;
}
sub EIBAddr {
 my $addr = undef;
 return \$addr;
}
sub EIBInt8 {
 my $data = undef;
 return \$data;
}
sub EIBInt16 {
 my $data = undef;
 return \$data;
}
sub EIBInt32 {
 my $data = undef;
 return \$data;
}
1;
